using System;
using System.Drawing;

namespace NAPS2.Scan.Images.Transforms
{
    public static class ColorHelper
    {
        // From https://stackoverflow.com/a/1626175

        public static void ColorToHSV(Color color, out double hue, out double saturation, out double value)
        {
            int max = Math.Max(color.R, Math.Max(color.G, color.B));
            int min = Math.Min(color.R, Math.Min(color.G, color.B));

            hue = color.GetHue();
            saturation = (max == 0) ? 0 : 1d - (1d * min / max);
            value = max / 255d;
        }

        public static Color ColorFromHSV(double hue, double saturation, double value)
        {
            int hi = Convert.ToInt32(Math.Floor(hue / 60)) % 6;
            double f = (hue / 60) - Math.Floor(hue / 60);

            value *= 255;
            int v = Convert.ToInt32(value);
            int p = Convert.ToInt32(value * (1 - saturation));
            int q = Convert.ToInt32(value * (1 - (f * saturation)));
            int t = Convert.ToInt32(value * (1 - ((1 - f) * saturation)));
            switch (hi)
            {
                case 0:
                    return Color.FromArgb(255, v, t, p);

                case 1:
                    return Color.FromArgb(255, q, v, p);

                case 2:
                    return Color.FromArgb(255, p, v, t);

                case 3:
                    return Color.FromArgb(255, p, q, v);

                case 4:
                    return Color.FromArgb(255, t, p, v);

                default:
                    return Color.FromArgb(255, v, p, q);
            }
        }

        public static void ColorToHSL(Color color, out double hue, out double saturation, out double brightness)
        {
            hue = color.GetHue();
            saturation = color.GetSaturation();
            brightness = color.GetBrightness();
        }

        // From https://blogs.msdn.microsoft.com/cjacks/2006/04/12/converting-from-hsb-to-rgb-in-net/
        public static Color ColorFromHSL(double h, double s, double b)
        {
            const int a = 255;

            if (Math.Abs(s) < Single.Epsilon)
            {
                return Color.FromArgb(a, Convert.ToInt32(b * 255),
                    Convert.ToInt32(b * 255), Convert.ToInt32(b * 255));
            }

            double fMax, fMid, fMin;
            int iSextant, iMax, iMid, iMin;

            if (0.5 < b)
            {
                fMax = b - (b * s) + s;
                fMin = b + (b * s) - s;
            }
            else
            {
                fMax = b + (b * s);
                fMin = b - (b * s);
            }

            iSextant = (int)Math.Floor(h / 60f);
            if (300f <= h)
            {
                h -= 360f;
            }
            h /= 60f;
            h -= 2f * (double)Math.Floor(((iSextant + 1f) % 6f) / 2f);
            if (0 == iSextant % 2)
            {
                fMid = (h * (fMax - fMin)) + fMin;
            }
            else
            {
                fMid = fMin - (h * (fMax - fMin));
            }

            iMax = Convert.ToInt32(fMax * 255);
            iMid = Convert.ToInt32(fMid * 255);
            iMin = Convert.ToInt32(fMin * 255);

            switch (iSextant)
            {
                case 1:
                    return Color.FromArgb(a, iMid, iMax, iMin);

                case 2:
                    return Color.FromArgb(a, iMin, iMax, iMid);

                case 3:
                    return Color.FromArgb(a, iMin, iMid, iMax);

                case 4:
                    return Color.FromArgb(a, iMid, iMin, iMax);

                case 5:
                    return Color.FromArgb(a, iMax, iMin, iMid);

                default:
                    return Color.FromArgb(a, iMax, iMid, iMin);
            }
        }
    }
}